# 我的刷题笔记 
根据本书，我自己的刷题笔记

## 1. 核心讨论篇
快速看掉、很快很快

1.7 滑动窗口 稍微有点难度，可以慢点看

1~6 能很快刷完


刷题：
**先刷二叉树，先刷二叉树，先刷二叉树**！

二叉树：  
- [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)
- [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
- [99. 恢复二叉搜索树](https://leetcode-cn.com/problems/recover-binary-search-tree/)

动态规划：  
- [509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number)
- [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change)

回溯算法：  
- [46. 全排列](https://leetcode-cn.com/problems/permutations)
- [51. N皇后](https://leetcode-cn.com/problems/n-queens)

BFS：  
- [111. 二叉树的最小深度（简单）](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree)
- [752. 打开转盘锁（中等）](https://leetcode-cn.com/problems/open-the-lock)

双指针：  
- [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle)
- [141. 环形链表II](https://leetcode-cn.com/problems/linked-list-cycle-ii)
- [167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted)
- [876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list)
- [2095. 删除链表的中间节点](https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list)
- [704. 二分查找](https://leetcode-cn.com/problems/binary-search)
- [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array)

滑动窗口 (双指针)：
- [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring)
- [567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string)
- [438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string)
- [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters)


## 2. 动态规划系列
- [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence)
- [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray)
- [1143.最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence)
- [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance)
- [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence)
- [516.最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence)
- [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring)
- [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching)
- [887. 鸡蛋掉落](https://leetcode-cn.com/problems/super-egg-drop)
- [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change) 
- [312. 戳气球](https://leetcode-cn.com/problems/burst-balloons)


**重点：**
[2.7 - 子序列问题解题模板：最长回文子序列](./第2章-动态规划系列/2.7-子序列问题解题模板：最长回文子序列.md)
这里提到的两种思路模板，都是动态规划的解题套路。
- **第一种思路模板是一个一维的 dp 数组**：
```java
int n = array.length;

int[] dp = new int[n];
for (int i = 1; i < n; i++) {
    for (int j = 0; j < i; j++) {
        dp[i] = 最值(dp[i], dp[j] + ...)
    }
}
```
如 [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence) 

- **第二种思路模板是一个二维的 dp 数组**：
```java
int M = arr1.length;
int N = arr2.length;

int[][] dp = new int[M + 1][N + 1];
for (int i = 0; i <= M; i++) {
    for (int j = 0; j <= N; j++) {
        if (arr[i] == arr[j]) 
            dp[i][j] = dp[i][j] + ...
        else
            dp[i][j] = 最值(...)
    }
}
```
这种思路运用相对更多一些，尤其是涉及两个字符串/数组的子序列，比如前文讲的「最长公共子序列」。本思路中 dp 数组含义又分为「只涉及一个字符串」和「涉及两个字符串」两种情况。

- 2.1 涉及两个字符串/数组时（比如最长公共子序列），dp 数组的含义如下：

在子数组 arr1[0..i] 和子数组 arr2[0..j] 中，我们要求的子序列（最长公共子序列）长度为 dp[i][j]。

- 2.2 只涉及一个字符串/数组时（比如本文要讲的最长回文子序列），dp 数组的含义如下：

在子数组 array[i..j] 中，我们要求的子序列（最长回文子序列）的长度为 dp[i][j]。

**去看 2.7 这个原文！**

[x] **2.8 状态压缩** 这个可以先不看



**2.15 - 2.17 背包问题**
- [01背包](https://www.nowcoder.com/practice/2820ea076d144b30806e72de5e5d4bbf)
- [完全背包](https://www.nowcoder.com/practice/664ccf702ddb43a986e95f41c1196718)
- [512. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/) 【完全背包问题】


